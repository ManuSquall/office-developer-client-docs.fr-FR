---
title: Collaboration des gestionnaires d’événements
TOCTitle: How event handlers work together
ms:assetid: 02122824-881e-0bb8-cba1-c963024790ae
ms:mtpsurl: https://msdn.microsoft.com/library/JJ248788(v=office.15)
ms:contentKeyID: 48542951
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: e772e93f27d6bb5f30d865e3435d4bde6bdc5e73
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/23/2019
ms.locfileid: "32291921"
---
# <a name="how-event-handlers-work-together"></a><span data-ttu-id="1e5a0-102">Collaboration des gestionnaires d’événements</span><span class="sxs-lookup"><span data-stu-id="1e5a0-102">How event handlers work together</span></span>

<span data-ttu-id="1e5a0-103">**S’applique à** : Access 2013, Office 2013</span><span class="sxs-lookup"><span data-stu-id="1e5a0-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="1e5a0-p101">À moins que vous ne programmiez en Visual Basic, tous les gestionnaires des événements **Connection** et **Recordset** doivent être implémentés, que vous décidiez de traiter ou non tous les événements. La charge de travail qu'implique cette implémentation dépend de votre langage de programmation. Pour plus d'informations, consultez [Instanciation des événements ADO par langage](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado).</span><span class="sxs-lookup"><span data-stu-id="1e5a0-p101">Unless you are programming in Visual Basic, all event handlers for **Connection** and **Recordset** events must be implemented, regardless of whether you actually process all of the events. The amount of implementation work you have to do depends on your programming language. For more information, see [ADO Event Instantiation by Language](https://docs.microsoft.com/office/client-developer/access/desktop-database-reference/ado-event-instantiation-by-language-ado).</span></span>

## <a name="paired-event-handlers"></a><span data-ttu-id="1e5a0-107">Des handlers d’événements associés</span><span class="sxs-lookup"><span data-stu-id="1e5a0-107">Paired event handlers</span></span>

<span data-ttu-id="1e5a0-p102">Chaque gestionnaire d'événements Will est associé à un gestionnaire d'événements Complete. Par exemple, lorsque votre application modifie la valeur d'un champ, le gestionnaire d'événements **WillChangeField** est appelé. Si la modification est acceptable, l'application conserve le paramètre **adStatus** inchangé et l'opération est effectuée. Au terme de l'opération, un événement **FieldChangeComplete** notifie votre application que l'opération est terminée. Si elle s'est correctement déroulée, le paramètre **adStatus** contient **adStatusOK**. Dans le cas contraire, **adStatus** contient **adStatusErrorsOccurred**. Vous devez alors examiner l'objet **Error** pour déterminer la cause de l'erreur.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-p102">Each Will event handler has an associated Complete event handler. For example, when your application changes the value of a field, the **WillChangeField** event handler is called. If the change is acceptable, your application leaves the **adStatus** parameter unchanged and the operation is performed. When the operation completes, a **FieldChangeComplete** event notifies your application that the operation has finished. If it completed successfully, **adStatus** contains **adStatusOK**; otherwise, **adStatus** contains **adStatusErrorsOccurred** and you must check the **Error** object to determine the cause of the error.</span></span>

<span data-ttu-id="1e5a0-p103">Lorsque **WillChangeField** est appelé, vous pouvez décider de ne pas apporter de modification. Dans ce cas, **adStatus** doit être défini avec la valeur **adStatusCancel**. L'opération est annulée et l'événement **FieldChangeComplete** reçoit un paramètre **adStatus** avec la valeur **adStatusErrorsOccurred**. L'objet **Error** contient **adErrOperationCancelled** de sorte que le gestionnaire **FieldChangeComplete** sait que l'opération a été annulée. Toutefois, vous devez vérifier la valeur du paramètre **adStatus** avant de le modifier, car la définition de **adStatus** à **adStatusCancel** n'a aucune incidence si le paramètre avait la valeur **adStatusCantDeny** au moment où vous avez commencé la procédure.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-p103">When **WillChangeField** is called, you might determine that the change should not be made. In that case, set **adStatus** to **adStatusCancel**. The operation is canceled and the **FieldChangeComplete** event receives an **adStatus** value of **adStatusErrorsOccurred**. The **Error** object contains **adErrOperationCancelled** so that your **FieldChangeComplete** handler knows that the operation was canceled. However, you need to check the value of the **adStatus** parameter before changing it, because setting **adStatus** to **adStatusCancel** has no effect if the parameter was set to **adStatusCantDeny** on entry to the procedure.</span></span>

<span data-ttu-id="1e5a0-p104">Il arrive qu'une opération génère plusieurs événements. Par exemple, l'objet **Recordset** possède des événements associés lorsque des objets **Field** et **Record** sont modifiés. Lorsque votre application modifie la valeur d'un objet **Field**, le gestionnaire d'événements **WillChangeField** est appelé. S'il détermine que l'opération peut continuer, le gestionnaire d'événements **WillChangeRecord** est également appelé. Si celui-ci autorise également l'événement à se poursuivre, la modification a lieu et les gestionnaires d'événements **FieldChangeComplete** et **RecordChangeComplete** sont appelés. L'ordre dans lequel les gestionnaires d'événements Will pour une opération donnée sont appelés n'est pas défini. Pour cette raison, évitez d'écrire du code reposant sur un ordre précis des appels des gestionnaires.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-p104">Sometimes an operation can raise more than one event. For example, the **Recordset** object has paired events for **Field** changes and **Record** changes. When your application changes the value of a **Field**, the **WillChangeField** event handler is called. If it determines that the operation can continue, the **WillChangeRecord** event handler is also raised. If this handler also allows the event to continue, the change is made and the **FieldChangeComplete** and **RecordChangeComplete** event handlers are called. The order in which the Will event handlers for a particular operation are called is not defined, so you should avoid writing code that depends on calling handlers in a particular sequence.</span></span>

<span data-ttu-id="1e5a0-p105">Dans les cas où plusieurs événements Will sont générés, il se peut que l'un d'entre eux annule l'opération en attente. Par exemple, si votre application modifie la valeur d'un objet **Field**, les gestionnaires d'événements **WillChangeField** et **WillChangeRecord** doivent normalement être appelés tous les deux. Cependant, si l'opération est annulée dans le premier gestionnaire d'événements, le gestionnaire Complete associé est immédiatement appelé avec **adStatusOperationCancelled**. Le second gestionnaire d'événements n'est jamais appelé. Si, toutefois, le premier gestionnaire événements autorise l'événement à se poursuivre, le second est appelé. S'il annule ensuite l'opération, les deux événements Complete sont appelés comme dans les exemples précédents.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-p105">In instances when multiple Will events are raised, one of the events might cancel the pending operation. For example, when your application changes the value of a **Field**, both **WillChangeField** and **WillChangeRecord** event handlers would normally be called. However, if the operation is canceled in the first event handler, its associated Complete handler is immediately called with **adStatusOperationCancelled**. The second handler is never called. If, however, the first event handler allows the event to proceed, the other event handler will be called. If it then cancels the operation, both Complete events will be called as in the earlier examples.</span></span>

## <a name="unpaired-event-handlers"></a><span data-ttu-id="1e5a0-130">Des handlers d’événements non publiés</span><span class="sxs-lookup"><span data-stu-id="1e5a0-130">Unpaired event handlers</span></span>

<span data-ttu-id="1e5a0-p106">Tant que l'état passé à l'événement n'est pas **adStatusCantDeny**, vous pouvez désactiver les notifications d'événement pour tous les événements en définissant le paramètre *Status* pour qu'il retourne **adStatusUnwantedEvent**. Par exemple, lors du premier appel du gestionnaire d'événements Complete, vous pouvez retourner **adStatusUnwantedEvent**. Vous ne recevrez par la suite que les événements Will. Cependant, certains événements peuvent être déclenchés pour plus d'une raison. Dans ce cas, l'événement est associé à un paramètre *Reason*. Lorsque vous retournez **adStatusUnwantedEvent**, vous ne recevrez plus de notifications pour cet événement s'il se produit pour la raison définie. En d'autres termes, il se peut que vous receviez une notification pour chaque autre raison déclenchant l'événement.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-p106">As long as the status passed to the event is not **adStatusCantDeny**, you can turn off event notifications for any event by returning **adStatusUnwantedEvent** in the *Status* parameter. For example, when your Complete event handler is called the first time, you can return **adStatusUnwantedEvent**. You will subsequently receive only Will events. However, some events can be triggered for more than one reason. In that case, the event will have a *Reason* parameter. When you return **adStatusUnwantedEvent**, you will stop receiving notifications for that event only when they occur for that particular reason. In other words, you will potentially receive notification for each possible reason that the event could be triggered.</span></span>

<span data-ttu-id="1e5a0-p107">Dans certains cas, les gestionnaires d'événements Will uniques sont utiles pour examiner les paramètres utilisés dans une opération. Vous pouvez modifier ces paramètres d'opération ou annuler l'opération</span><span class="sxs-lookup"><span data-stu-id="1e5a0-p107">Single Will event handlers can be useful when you want to examine the parameters that will be used in an operation. You can modify those operation parameters or cancel the operation.</span></span>

<span data-ttu-id="1e5a0-p108">Vous pouvez également conserver la notification d'événements Complete activée. Lorsque le premier gestionnaire d'événements Will est appelé, retournez **adStatusUnwantedEvent**. Vous ne recevrez par la suite que les événements Complete.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-p108">Alternatively, leave Complete event notification enabled. When your first Will event handler is called, return **adStatusUnwantedEvent**. You will subsequently receive only Complete events.</span></span>

<span data-ttu-id="1e5a0-p109">Les gestionnaires d'événements Complete uniques peuvent être utiles pour gérer les opérations asynchrones. Chaque opération asynchrone est associée à un événement Complete approprié.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-p109">Single Complete event handlers can be useful for managing asynchronous operations. Each asynchronous operation has an appropriate Complete event.</span></span>

<span data-ttu-id="1e5a0-145">Par exemple, le remplissage d'un objet [Recordset](recordset-object-ado.md) volumineux peut être long.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-145">For example, it can take a long time to populate a large [Recordset](recordset-object-ado.md) object.</span></span> <span data-ttu-id="1e5a0-146">Si votre application est correctement écrite, vous pouvez démarrer une opération et continuer avec d’autres traitements.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-146">If your application is appropriately written, you can start a operation and continue with other processing.</span></span> <span data-ttu-id="1e5a0-147">Vous serez averti de la fin du remplissage de l'objet **Recordset** par un événement **ExecuteComplete**.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-147">You will eventually be notified when the **Recordset** is populated by an **ExecuteComplete** event.</span></span>

## <a name="single-event-handlers-and-multiple-objects"></a><span data-ttu-id="1e5a0-148">Des handlers d’événements et plusieurs objets</span><span class="sxs-lookup"><span data-stu-id="1e5a0-148">Single event handlers and multiple objects</span></span>

<span data-ttu-id="1e5a0-p111">La souplesse d'un langage de programmation tel que Microsoft Visual C++ vous permet de n'utiliser qu'un gestionnaire pour traiter les événements liés à plusieurs objets. Par exemple, vous pouvez n'avoir qu'un seul gestionnaire d'événements **Disconnect** pour traiter les événements de plusieurs objets **Connection**. Si l'une des connexions se termine, le gestionnaire d'événements **Disconnect** est appelé. Vous pouvez déterminer la connexion à l'origine de l'événement, car le paramètre d'objet du gestionnaire d'événements sera défini avec l'objet **Connection** correspondant</span><span class="sxs-lookup"><span data-stu-id="1e5a0-p111">The flexibility of a programming language like Microsoft Visual C++ enables you to have one event handler process events from multiple objects. For example, you could have one **Disconnect** event handler process events from several **Connection** objects. If one of the connections ended, the **Disconnect** event handler would be called. You could tell which connection caused the event because the event-handler object parameter would be set to the corresponding **Connection** object.</span></span>

> [!NOTE]
> <span data-ttu-id="1e5a0-153">[!REMARQUE] Vous ne pouvez pas utiliser cette technique en Visual Basic, car ce langage ne peut associer qu'un seul objet à un gestionnaire d'événements.</span><span class="sxs-lookup"><span data-stu-id="1e5a0-153">This technique cannot be used in Visual Basic because that language can correlate only one object to an event handler.</span></span>


