---
title: Curseurs de jeu de clés (référence de base de données de bureau Access)
TOCTitle: Keyset cursors
ms:assetid: 4b6e5f90-4413-4fb3-0a08-2cb89d3c61f7
ms:mtpsurl: https://msdn.microsoft.com/library/JJ249236(v=office.15)
ms:contentKeyID: 48544690
ms.date: 09/18/2015
mtps_version: v=office.15
localization_priority: Normal
ms.openlocfilehash: 200b10599683a5b5877952664c04e94b2523cfee
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/23/2019
ms.locfileid: "32290714"
---
# <a name="keyset-cursors"></a><span data-ttu-id="cc932-102">Curseurs de jeu de clés</span><span class="sxs-lookup"><span data-stu-id="cc932-102">Keyset cursors</span></span>

<span data-ttu-id="cc932-103">**S’applique à** : Access 2013, Office 2013</span><span class="sxs-lookup"><span data-stu-id="cc932-103">**Applies to**: Access 2013, Office 2013</span></span>

<span data-ttu-id="cc932-p101">Sa capacité à détecter les modifications place le curseur de jeu de clés entre le curseur statique et le curseur dynamique. À l'instar du curseur statique, il ne détecte pas toujours les changements apportés à l'appartenance et à l'ordre du jeu de résultats. À l'instar du curseur dynamique, il détecte les changements apportés aux valeurs des lignes du jeu de résultats.</span><span class="sxs-lookup"><span data-stu-id="cc932-p101">The keyset cursor provides functionality between a static and a dynamic cursor in its ability to detect changes. Like a static cursor, it does not always detect changes to the membership and order of the result set. Like a dynamic cursor, it does detect changes to the values of rows in the result set.</span></span>

<span data-ttu-id="cc932-p102">Les curseurs de jeu de clés sont contrôlés par un ensemble d'identificateurs uniques (clés) appelé jeu de clés. Ces clés sont conçues à partir d'un jeu de colonnes qui identifient de manière unique les lignes du jeu de résultats. Le jeu de clés désigne l'ensemble des valeurs de clés de toutes les lignes renvoyées par l'instruction de requête.</span><span class="sxs-lookup"><span data-stu-id="cc932-p102">Keyset-driven cursors are controlled by a set of unique identifiers (keys) known as the keyset. The keys are built from a set of columns that uniquely identify the rows in the result set. The keyset is the set of key values from all the rows returned by the query statement.</span></span>

<span data-ttu-id="cc932-p103">Avec les curseurs de jeu de clés, une clé est générée et enregistrée pour chaque ligne du curseur et stockée sur la station de travail cliente ou sur le serveur. Lorsque vous accédez à une ligne, la clé stockée est utilisée pour extraire les valeurs de données courantes de la source de données. Dans un curseur de jeu de clés, l'appartenance du jeu de résultats est figée lorsque le jeu de clés est saturé. Par conséquent, les ajouts ou mises à jour affectant l'appartenance ne font pas partie du jeu de résultats tant qu'il n'est pas rouvert.</span><span class="sxs-lookup"><span data-stu-id="cc932-p103">With keyset-driven cursors, a key is built and saved for each row in the cursor and stored either on the client workstation or on the server. When you access each row, the stored key is used to fetch the current data values from the data source. In a keyset-driven cursor, result set membership is frozen when the keyset is fully populated. Thereafter, additions or updates that affect membership are not a part of the result set until it is reopened.</span></span>

<span data-ttu-id="cc932-p104">Les modifications apportées aux valeurs de données (soit par le propriétaire du jeu de clés, soit par d'autres processus) sont visibles lorsque l'utilisateur fait défiler le jeu de résultats. Les insertions effectuées en dehors du curseur (par d'autres processus) ne sont visibles que si le curseur est fermé, puis rouvert. Les insertions effectuées à l'intérieur du curseur sont visibles à la fin du jeu de résultats.</span><span class="sxs-lookup"><span data-stu-id="cc932-p104">Changes to data values (made either by the keyset owner or other processes) are visible as the user scrolls through the result set. Inserts made outside the cursor (by other processes) are visible only if the cursor is closed and reopened. Inserts made from inside the cursor are visible at the end of the result set.</span></span>

<span data-ttu-id="cc932-p105">Lorsqu'un curseur de jeu de clés tente d'extraire une ligne supprimée, la ligne apparaît comme un « trou » dans le jeu de résultats. La clé de la ligne existe dans le jeu de clés, mais la ligne n'existe plus dans le jeu de résultats. Si les valeurs de clés d'une ligne sont mises à jour, la ligne est considérée comme supprimée, puis insérée. Par conséquent, de telles lignes apparaissent comme des trous dans le jeu de résultats. Alors qu'un curseur de jeu de clés peut toujours détecter les lignes supprimées par d'autres processus, il ne peut pas toujours supprimer les clés des lignes qu'il a lui-même supprimées. Les curseurs de jeu de clés qui le font ne peuvent pas détecter leurs propres suppressions car il n'en reste aucune trace.</span><span class="sxs-lookup"><span data-stu-id="cc932-p105">When a keyset-driven cursor attempts to retrieve a row that has been deleted, the row appears as a "hole" in the result set. The key for the row exists in the keyset, but the row no longer exists in the result set. If the key values in a row are updated, the row is considered to have been deleted and then inserted, so such rows also appear as holes in the result set. While a keyset-driven cursor can always detect rows deleted by other processes, it can optionally remove the keys for rows it deletes itself. Keyset-driven cursors that do this cannot detect their own deletes because the evidence has been removed.</span></span>

<span data-ttu-id="cc932-p106">Une mise à jour d'une colonne de clé se déroule de la façon suivante : l'ancienne clé est d'abord supprimée, puis la nouvelle est insérée. La nouvelle valeur de clé n'est pas visible si la mise à jour n'a pas été réalisée à l'aide du curseur. Si elle a été réalisée avec le curseur, cette valeur apparaît à la fin du jeu de résultats.</span><span class="sxs-lookup"><span data-stu-id="cc932-p106">An update to a key column operates like a delete of the old key followed by an insert of the new key. The new key value is not visible if the update was not made through the cursor. If the update was made through the cursor, the new key value is visible at the end of the result set.</span></span>

<span data-ttu-id="cc932-p107">Il existe une variante des curseurs de jeu de clés appelée curseurs standard de jeu de clés. Dans ce type de curseur, l'appartenance des lignes du jeu de résultats et leur ordre sont définis à l'ouverture du curseur, mais les modifications apportées aux valeurs par le propriétaire du curseur et les modifications validées réalisées par d'autres processus sont visibles. Si une modification modifie l'appartenance d'une ligne ou affecte son ordre, cette ligne ne disparaît ni ne bouge tant que le curseur n'est pas fermé, puis rouvert. Les données insérées n'apparaissent pas, mais les changements apportés aux données existantes apparaissent lorsque les lignes sont extraites.</span><span class="sxs-lookup"><span data-stu-id="cc932-p107">There is a variation on keyset-driven cursors called keyset-driven standard cursors. In a keyset-driven standard cursor, the membership of rows in the result set and the order of the rows are fixed at cursor open time, but changes to values that are made by the cursor owner and committed changes made by other processes are visible. If a change disqualifies a row for membership or affects the order of a row, the row does not disappear or move unless the cursor is closed and reopened. Inserted data does not appear, but changes to existing data do appear as the rows are fetched.</span></span>

<span data-ttu-id="cc932-p108">Le curseur de jeu de clés est difficile à utiliser correctement car la sensibilité envers les changements de données dépend d'une variété de circonstances différentes, comme décrit ci-dessus. Cependant, si votre application n'est pas affectée par les mises à jour concurrentes, peut gérer les mauvaises clés avec des programmes et doit accéder directement à certaines lignes dotées de clés, ce type de curseur vous convient. Utilisez **adOpenKeyset** **CursorTypeEnum** pour signaler que vous souhaitez utiliser un curseur de jeu de clés dans ADO.</span><span class="sxs-lookup"><span data-stu-id="cc932-p108">The keyset-driven cursor is difficult to use correctly because the sensitivity to data changes depends on many differing circumstances, as described above. However, if your application is not concerned with concurrent updates, can programmatically handle bad keys, and must directly access certain keyed rows, the keyset-driven cursor might work for you. Use the **adOpenKeyset** **CursorTypeEnum** to indicate that you want to use a keyset cursor in ADO.</span></span>

