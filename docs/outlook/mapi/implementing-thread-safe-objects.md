---
title: Implémentation d'objets thread-safe
manager: soliver
ms.date: 11/16/2014
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 3c911694-b953-4d35-9a3a-22c17cfd79bc
description: 'Dernière modification : 23 juillet 2011'
ms.openlocfilehash: 9160136542c7960bad0be2423872171b17d99fe3
ms.sourcegitcommit: 8fe462c32b91c87911942c188f3445e85a54137c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/23/2019
ms.locfileid: "32310037"
---
# <a name="implementing-thread-safe-objects"></a><span data-ttu-id="85315-103">Implémentation d'objets thread-safe</span><span class="sxs-lookup"><span data-stu-id="85315-103">Implementing Thread-Safe Objects</span></span>

  
  
<span data-ttu-id="85315-104">**S’applique à** : Outlook 2013 | Outlook 2016</span><span class="sxs-lookup"><span data-stu-id="85315-104">**Applies to**: Outlook 2013 | Outlook 2016</span></span> 
  
<span data-ttu-id="85315-105">Avec les objets qui sont renvoyés à partir des appels de méthode d'interface directement, il incombe au fournisseur de s'assurer de la sécurité des threads.</span><span class="sxs-lookup"><span data-stu-id="85315-105">With objects that are returned from interface method calls directly, it is the provider's responsibility to ensure thread-safety.</span></span> <span data-ttu-id="85315-106">Avec les objets callback, il s'agit de la responsabilité de l'application cliente.</span><span class="sxs-lookup"><span data-stu-id="85315-106">With callback objects, it is the client application's responsibility.</span></span>
  
<span data-ttu-id="85315-107">Un client peut implémenter un rappel de notification thread-safe en appelant l'utilitaire MAPI [HrThisThreadAdviseSink](hrthisthreadadvisesink.md).</span><span class="sxs-lookup"><span data-stu-id="85315-107">A client can implement a thread-safe notification callback by calling the MAPI utility [HrThisThreadAdviseSink](hrthisthreadadvisesink.md).</span></span> <span data-ttu-id="85315-108">**HrThisThreadAdviseSink** transforme un récepteur de conseillers non thread-safe en un récepteur thread-safe.</span><span class="sxs-lookup"><span data-stu-id="85315-108">**HrThisThreadAdviseSink** transforms a non-thread-safe advise sink into a thread-safe one.</span></span> <span data-ttu-id="85315-109">Pour les rappels de progression, il n'existe pas d'utilitaire de ce type.</span><span class="sxs-lookup"><span data-stu-id="85315-109">For progress callbacks, there is no such utility.</span></span> <span data-ttu-id="85315-110">Un client peut choisir d'utiliser l'objet de progression thread-safe MAPI ou d'en créer un manuellement.</span><span class="sxs-lookup"><span data-stu-id="85315-110">A client can choose to use the MAPI thread-safe progress object or create one manually.</span></span> 
  
<span data-ttu-id="85315-111">Un objet thread-safe peut également ou non être pris en charge par les threads.</span><span class="sxs-lookup"><span data-stu-id="85315-111">A thread-safe object might or might not also be thread-aware.</span></span> <span data-ttu-id="85315-112">Un objet lié à un thread gère un contexte distinct pour chaque thread qui l'utilise.</span><span class="sxs-lookup"><span data-stu-id="85315-112">A thread-aware object maintains a separate context for every thread that is using it.</span></span> <span data-ttu-id="85315-113">Les fournisseurs de services ne sont pas tenus de prendre en charge la détection des threads dans leurs objets thread-safe, bien que la prise en charge de la détection des threads puisse être utile dans certaines situations.</span><span class="sxs-lookup"><span data-stu-id="85315-113">Service providers are not required to support thread-awareness in their thread-safe objects, although supporting thread-awareness can be useful in some situations.</span></span> <span data-ttu-id="85315-114">Deux tables MAPI fournissent toujours leur propre contexte par définition.</span><span class="sxs-lookup"><span data-stu-id="85315-114">Two MAPI tables always provide their own context by definition.</span></span> <span data-ttu-id="85315-115">Une table utilisée sur des threads différents ne doit pas fournir de contexte unique.</span><span class="sxs-lookup"><span data-stu-id="85315-115">One table used on different threads does not and should not provide unique context.</span></span>
  
<span data-ttu-id="85315-116">Un client peut choisir entre recevoir des notifications sur le même thread que celui utilisé pour l'appel **MAPIInitialize** , sur le même thread que celui utilisé pour l'appel de la fonction Advise ou sur un thread distinct appartenant à MAPI. \*\*\*\*</span><span class="sxs-lookup"><span data-stu-id="85315-116">A client can choose between receiving notifications on the same thread that was used for the **MAPIInitialize** call, on the same thread that was used for the **Advise** call, or on a separate thread owned by MAPI.</span></span> <span data-ttu-id="85315-117">Pour vous assurer que les notifications arrivent sur le même thread que celui utilisé pour appeler **MAPIInitialize**, un client appelle [MAPIInitialize](mapiinitialize.md) et transmet zéro dans le membre **ulFlags** de la structure [MAPIINIT_0](mapiinit_0.md) .</span><span class="sxs-lookup"><span data-stu-id="85315-117">To ensure that notifications arrive on the same thread that was used to call **MAPIInitialize**, a client calls [MAPIInitialize](mapiinitialize.md) and passes zero in the **ulFlags** member of the [MAPIINIT_0](mapiinit_0.md) structure.</span></span> <span data-ttu-id="85315-118">Les notifications sont ensuite remises lors de la boucle de message principale.</span><span class="sxs-lookup"><span data-stu-id="85315-118">Notifications are then delivered during the main message loop.</span></span> 
  
<span data-ttu-id="85315-119">Pour recevoir des notifications sur le thread appartenant à MAPI, un client appelle **MAPIInitialize** avec le membre **ulFlags** de la structure **MAPIINIT_0** définie sur MAPI_MULTITHREAD_NOTIFICATIONS.</span><span class="sxs-lookup"><span data-stu-id="85315-119">To receive notifications on the MAPI-owned thread, a client calls **MAPIInitialize** with the **ulFlags** member of the **MAPIINIT_0** structure set to MAPI_MULTITHREAD_NOTIFICATIONS.</span></span> <span data-ttu-id="85315-120">L' \*\*\*\* appel de la fonction Advise est effectué avec l'objet de récepteur de notification du client au lieu d'une version enveloppée.</span><span class="sxs-lookup"><span data-stu-id="85315-120">The **Advise** call is made with the client's advise sink object rather than a wrapped version.</span></span> 
  
<span data-ttu-id="85315-121">Pour vous assurer que les notifications arrivent sur le même thread que celui \*\*\*\* utilisé pour appeler Advise, un client appelle [HrThisThreadAdviseSink](hrthisthreadadvisesink.md) et transmet le récepteur de notifications renvoyées nouvellement créé à des **conseils** au lieu du récepteur de notification d'origine.</span><span class="sxs-lookup"><span data-stu-id="85315-121">To ensure that notifications arrive on the same thread that was used to call **Advise**, a client calls [HrThisThreadAdviseSink](hrthisthreadadvisesink.md) and passes the newly created wrapped advise sink to **Advise** rather than the original advise sink.</span></span> <span data-ttu-id="85315-122">**MAPIInitialize** peut être appelé avec n'importe quelle valeur d'indicateur.</span><span class="sxs-lookup"><span data-stu-id="85315-122">**MAPIInitialize** can be called with either flag value.</span></span> 
  

