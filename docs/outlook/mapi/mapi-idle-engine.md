---
title: Moteur d’inactivité MAPI
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 755d096a-2a61-44d2-a765-5d464a857756
description: 'Derni�re modification�: lundi 9 mars 2015'
ms.openlocfilehash: c535da245be09f930a70c5fae2a892f33087ebf9
ms.sourcegitcommit: 9d60cd82b5413446e5bc8ace2cd689f683fb41a7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/11/2018
ms.locfileid: "19784630"
---
# <a name="mapi-idle-engine"></a><span data-ttu-id="1d08c-103">Moteur d’inactivité MAPI</span><span class="sxs-lookup"><span data-stu-id="1d08c-103">MAPI Idle Engine</span></span>

  
  
<span data-ttu-id="1d08c-104">**S’applique à**: Outlook</span><span class="sxs-lookup"><span data-stu-id="1d08c-104">**Applies to**: Outlook</span></span> 
  
<span data-ttu-id="1d08c-105">MAPI offre plusieurs fonctions qui constituent le moteur inactif.</span><span class="sxs-lookup"><span data-stu-id="1d08c-105">MAPI provides several functions that are collectively known as the idle engine.</span></span> <span data-ttu-id="1d08c-106">Ces fonctions permettent de clients, fournisseurs de carnet d’adresses et les fournisseurs de banque de messages effectuer diverses tâches pendant les heures de lentes dans la session ou en réponse à un moment lent.</span><span class="sxs-lookup"><span data-stu-id="1d08c-106">These functions allow clients, address book providers, and message store providers to perform various tasks during slow times in the session or in response to a slow time.</span></span> <span data-ttu-id="1d08c-107">Par exemple, clients et fournisseurs de services peuvent différer des opérations lentes ou fermer les fichiers qui sont restés inutilisés pendant une longue période.</span><span class="sxs-lookup"><span data-stu-id="1d08c-107">For example, clients and service providers can defer slow operations or close files that have remained unused for a lengthy period.</span></span> <span data-ttu-id="1d08c-108">Généralement, les fournisseurs de transport n’utilisent pas du moteur inactif, car la méthode **IXPLogon::Idle** prend sa place.</span><span class="sxs-lookup"><span data-stu-id="1d08c-108">Transport providers typically do not use the idle engine because the **IXPLogon::Idle** method takes its place.</span></span> <span data-ttu-id="1d08c-109">Pour plus d’informations, voir [IXPLogon::Idle](ixplogon-idle.md).</span><span class="sxs-lookup"><span data-stu-id="1d08c-109">For more information, see [IXPLogon::Idle](ixplogon-idle.md).</span></span>
  
<span data-ttu-id="1d08c-110">Pour utiliser le moteur d’inactivité, clients et fournisseurs de services de créer une fonction de rappel qui contient les tâches qui doivent se produire lorsque le sous-système MAPI est inactif.</span><span class="sxs-lookup"><span data-stu-id="1d08c-110">To use the idle engine, clients and service providers create a callback function that contains the tasks that should occur when the MAPI subsystem is idle.</span></span> <span data-ttu-id="1d08c-111">Lorsque MAPI détecte la durée d’inactivité, il appelle cette fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="1d08c-111">When MAPI detects idle time, it invokes this callback function.</span></span> <span data-ttu-id="1d08c-112">La fonction de rappel suit le prototype **FNIDLE** , défini comme suit :</span><span class="sxs-lookup"><span data-stu-id="1d08c-112">The callback function follows the **FNIDLE** prototype, defined as follows:</span></span> 
  
 `BOOL (STDAPICALLTYPE FNIDLE) (LPVOID lpvContext)`
  
<span data-ttu-id="1d08c-113">Pour plus d’informations, voir [FNIDLE](fnidle.md).</span><span class="sxs-lookup"><span data-stu-id="1d08c-113">For more information, see [FNIDLE](fnidle.md).</span></span>
  
<span data-ttu-id="1d08c-114">Les fonctions qui constituent le moteur inactif sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="1d08c-114">The functions that make up the idle engine are:</span></span>
  
[<span data-ttu-id="1d08c-115">ChangeIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="1d08c-115">ChangeIdleRoutine</span></span>](changeidleroutine.md)
  
[<span data-ttu-id="1d08c-116">DeregisterIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="1d08c-116">DeregisterIdleRoutine</span></span>](deregisteridleroutine.md)
  
[<span data-ttu-id="1d08c-117">EnableIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="1d08c-117">EnableIdleRoutine</span></span>](enableidleroutine.md)
  
[<span data-ttu-id="1d08c-118">FtgRegisterIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="1d08c-118">FtgRegisterIdleRoutine</span></span>](ftgregisteridleroutine.md)
  
[<span data-ttu-id="1d08c-119">MAPIDeInitIdle</span><span class="sxs-lookup"><span data-stu-id="1d08c-119">MAPIDeInitIdle</span></span>](mapideinitidle.md)
  
[<span data-ttu-id="1d08c-120">MAPIInitIdle</span><span class="sxs-lookup"><span data-stu-id="1d08c-120">MAPIInitIdle</span></span>](mapiinitidle.md)
  
<span data-ttu-id="1d08c-121">Pour enregistrer une fonction de rappel, clients et fournisseurs de services d’appel la fonction **FtgRegisterIdleRoutine** .</span><span class="sxs-lookup"><span data-stu-id="1d08c-121">To register a callback function, clients and service providers call the **FtgRegisterIdleRoutine** function.</span></span> <span data-ttu-id="1d08c-122">Les paramètres d’entrée sont une priorité facultative, un bloc de mémoire est passée à la fonction de rappel comme entrée, un laps de temps à utiliser en aucune manière appropriée, et un ensemble de l’option indicateurs.</span><span class="sxs-lookup"><span data-stu-id="1d08c-122">The input parameters include an optional priority, a block of memory that is passed to your callback function as input, an amount of time to be used in any way appropriate, and a set of option flags.</span></span> 
  
<span data-ttu-id="1d08c-123">Clients et fournisseurs de services peuvent spécifier une priorité dans le paramètre _priIdle_ qui contrôle le fonctionne de la fonction inactive ou zéro si la priorité n’est pas un problème.</span><span class="sxs-lookup"><span data-stu-id="1d08c-123">Clients and service providers can specify a priority in the  _priIdle_ parameter that controls how the idle function runs or specify zero if priority is not an issue.</span></span> <span data-ttu-id="1d08c-124">Étant donné que les nombres négatifs représentent une priorité supérieure à zéro ou à des nombres positifs, les opérations de recherche et la compression doivent être affectées à des nombres négatifs.</span><span class="sxs-lookup"><span data-stu-id="1d08c-124">Because negative numbers represent higher priorities than positive numbers or zero, compression and search operations should be assigned negative numbers.</span></span> <span data-ttu-id="1d08c-125">Les tâches qui se produisent une fois doivent être assignées à des nombres positifs.</span><span class="sxs-lookup"><span data-stu-id="1d08c-125">Tasks that occur once should be assigned positive numbers.</span></span> 
  
<span data-ttu-id="1d08c-126">Pour annuler l’enregistrement d’une fonction de rappel active, clients et fournisseurs de services appellent la fonction **DeregisterIdleRoutine** .</span><span class="sxs-lookup"><span data-stu-id="1d08c-126">To deregister an active callback function, clients and service providers call the **DeregisterIdleRoutine** function.</span></span> <span data-ttu-id="1d08c-127">**DeregisterIdleRoutine** fonctionne de manière asynchrone, il est possible de la fonction de rappel à appeler à tout moment pendant l’appel d’annuler l’enregistrement et peut-être même une fois que **DeregisterIdleRoutine** a renvoyé.</span><span class="sxs-lookup"><span data-stu-id="1d08c-127">Because **DeregisterIdleRoutine** operates asynchronously, it is possible for the callback function to be invoked at any time during the deregister call and possibly even after **DeregisterIdleRoutine** has returned.</span></span> 
  
<span data-ttu-id="1d08c-128">Pour modifier certaines ou toutes les caractéristiques d’une fonction de rappel, clients et fournisseurs de services appellent la fonction **ChangeIdleRoutine** .</span><span class="sxs-lookup"><span data-stu-id="1d08c-128">To modify some or all of the characteristics of a callback function, clients and service providers call the **ChangeIdleRoutine** function.</span></span> <span data-ttu-id="1d08c-129">**ChangeIdleRoutine** apporte les modifications en fonction du paramétrage de du paramètre flags _ircIdle_ ; **ChangeIdleRoutine** peut modifier la fonction elle-même, sa priorité, paramètre de l’heure et paramètre d’entrée.</span><span class="sxs-lookup"><span data-stu-id="1d08c-129">**ChangeIdleRoutine** makes changes according to how the flags parameter  _ircIdle_ is set; **ChangeIdleRoutine** can change the function itself, its priority, time setting, and input parameter.</span></span> 
  
<span data-ttu-id="1d08c-130">MAPI définit inactif le même que le système d’exploitation, lorsque le système d’exploitation dispose d’une définition.</span><span class="sxs-lookup"><span data-stu-id="1d08c-130">MAPI defines idle the same as the operating system, when the operating system has a definition.</span></span> <span data-ttu-id="1d08c-131">Win32, MAPI crée un thread de priorité classe inactif pour planifier les tâches inactives.</span><span class="sxs-lookup"><span data-stu-id="1d08c-131">On Win32, MAPI creates a thread with idle-class priority to schedule idle tasks.</span></span> <span data-ttu-id="1d08c-132">Ce thread effectue le suivi de l’heure et publie un message au thread qui doit exécuter la tâche d’inactivité de l’heure de son exécution.</span><span class="sxs-lookup"><span data-stu-id="1d08c-132">This thread keeps track of the time and posts a message to the thread that is to execute the idle task when the time for its execution arrives.</span></span> <span data-ttu-id="1d08c-133">Win32 planifie des threads, ne traite pas.</span><span class="sxs-lookup"><span data-stu-id="1d08c-133">Win32 schedules threads, not processes.</span></span> <span data-ttu-id="1d08c-134">Si les tâches qui ont une priorité plus élevée que celle inactif sont produisent sur la station de travail, la tâche d’inactivité ne doit pas obtenir planifiée pour l’exécution tant que les tâches sont terminées.</span><span class="sxs-lookup"><span data-stu-id="1d08c-134">If tasks that have a priority higher than the idle priority are occurring on the workstation, the idle task should not get scheduled for execution until the tasks have completed.</span></span> 
  
<span data-ttu-id="1d08c-135">Toutes les tâches inactives exécutées sur le thread qui a appelé **MAPIInitIdle**.</span><span class="sxs-lookup"><span data-stu-id="1d08c-135">All idle tasks run on the thread that called **MAPIInitIdle**.</span></span> <span data-ttu-id="1d08c-136">MAPI a un thread distinct pour la planification, mais lorsqu’une tâche d’inactivité devient éligible, il publie un message renvoyé sur le thread d’initialisation et de la tâche d’inactivité est exécutée.</span><span class="sxs-lookup"><span data-stu-id="1d08c-136">MAPI has a separate thread for scheduling, but when an idle task becomes eligible, it posts a message back over to the initialization thread and the idle task is executed there.</span></span> <span data-ttu-id="1d08c-137">Les implications des différents types de clients sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="1d08c-137">The implications for different types of clients are as follows.</span></span>
  
|<span data-ttu-id="1d08c-138">**Modèle de thread**</span><span class="sxs-lookup"><span data-stu-id="1d08c-138">**Threading model**</span></span>|<span data-ttu-id="1d08c-139">**Implication**</span><span class="sxs-lookup"><span data-stu-id="1d08c-139">**Implication**</span></span>|
|:-----|:-----|
|<span data-ttu-id="1d08c-140">Un seul thread</span><span class="sxs-lookup"><span data-stu-id="1d08c-140">Single-threaded</span></span>  <br/> |<span data-ttu-id="1d08c-141">Pas de problème.</span><span class="sxs-lookup"><span data-stu-id="1d08c-141">No problem.</span></span> <span data-ttu-id="1d08c-142">Fonctions inactives s’exécuter sur le thread principal de votre client et sont sérialisées par le biais de la boucle de message.</span><span class="sxs-lookup"><span data-stu-id="1d08c-142">Idle functions execute on your client's main thread and are serialized through the message loop.</span></span>  <br/> |
|<span data-ttu-id="1d08c-143">Libre de thread</span><span class="sxs-lookup"><span data-stu-id="1d08c-143">Free-threaded</span></span>  <br/> |<span data-ttu-id="1d08c-144">Fonctions inactives doivent être thread-safe, mais votre client a déjà l’infrastructure nécessaire.</span><span class="sxs-lookup"><span data-stu-id="1d08c-144">Idle functions must be thread-safe, but your client already has the necessary infrastructure.</span></span> <span data-ttu-id="1d08c-145">Votre client n’ayez pas du tout le moteur inactif MAPI.</span><span class="sxs-lookup"><span data-stu-id="1d08c-145">Your client might not need the MAPI idle engine at all.</span></span>  <br/> |
|<span data-ttu-id="1d08c-146">Cloisonnement sans thread</span><span class="sxs-lookup"><span data-stu-id="1d08c-146">Apartment-threaded</span></span>  <br/> |<span data-ttu-id="1d08c-147">Fonction inactive doit s’exécuter sur le même thread qui a enregistré s’il souhaite utiliser toutes les autres interfaces COM, OLE ou MAPI.</span><span class="sxs-lookup"><span data-stu-id="1d08c-147">Idle function has to execute on the same thread that registered it if it wants to use MAPI, OLE, or any other COM interfaces.</span></span> <span data-ttu-id="1d08c-148">La façon la plus simple consiste à enregistrer une fonction inactive MAPI qui publie un message au thread droite et distribuer la fonction « en » inactive directement à partir de la boucle de message de ce thread.</span><span class="sxs-lookup"><span data-stu-id="1d08c-148">The most straightforward way is to register an idle function with MAPI that posts a message to the right thread and dispatch the "real" idle function directly from that thread's message loop.</span></span>  <br/> |
   

