---
title: Moteur MAPI inactif
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
localization_priority: Normal
api_type:
- COM
ms.assetid: 755d096a-2a61-44d2-a765-5d464a857756
description: Dernière modification le 9 mars 2015
ms.openlocfilehash: d8d591c02bb621c16a1d1b46272b19573ea79785
ms.sourcegitcommit: 8657170d071f9bcf680aba50b9c07f2a4fb82283
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/28/2019
ms.locfileid: "33428451"
---
# <a name="mapi-idle-engine"></a><span data-ttu-id="8dc27-103">Moteur MAPI inactif</span><span class="sxs-lookup"><span data-stu-id="8dc27-103">MAPI Idle Engine</span></span>

  
  
<span data-ttu-id="8dc27-104">**S’applique à** : Outlook 2013 | Outlook 2016</span><span class="sxs-lookup"><span data-stu-id="8dc27-104">**Applies to**: Outlook 2013 | Outlook 2016</span></span> 
  
<span data-ttu-id="8dc27-105">MAPI fournit plusieurs fonctions qui sont collectivement appelées moteur inactif.</span><span class="sxs-lookup"><span data-stu-id="8dc27-105">MAPI provides several functions that are collectively known as the idle engine.</span></span> <span data-ttu-id="8dc27-106">Ces fonctions permettent aux clients, aux fournisseurs de carnets d’adresses et aux fournisseurs de magasins de messages d’effectuer diverses tâches pendant les périodes lentes de la session ou en réponse à un temps lent.</span><span class="sxs-lookup"><span data-stu-id="8dc27-106">These functions allow clients, address book providers, and message store providers to perform various tasks during slow times in the session or in response to a slow time.</span></span> <span data-ttu-id="8dc27-107">Par exemple, les clients et les fournisseurs de services peuvent différer les opérations lentes ou fermer des fichiers qui sont restés inutilisés pendant une longue période.</span><span class="sxs-lookup"><span data-stu-id="8dc27-107">For example, clients and service providers can defer slow operations or close files that have remained unused for a lengthy period.</span></span> <span data-ttu-id="8dc27-108">Les fournisseurs de transport n’utilisent généralement pas le moteur inactif, car la méthode **IXPLogon::Idle** prend sa place.</span><span class="sxs-lookup"><span data-stu-id="8dc27-108">Transport providers typically do not use the idle engine because the **IXPLogon::Idle** method takes its place.</span></span> <span data-ttu-id="8dc27-109">Pour plus d’informations, [voir IXPLogon::Idle](ixplogon-idle.md).</span><span class="sxs-lookup"><span data-stu-id="8dc27-109">For more information, see [IXPLogon::Idle](ixplogon-idle.md).</span></span>
  
<span data-ttu-id="8dc27-110">Pour utiliser le moteur inactif, les clients et les fournisseurs de services créent une fonction de rappel qui contient les tâches qui doivent se produire lorsque le sous-système MAPI est inactif.</span><span class="sxs-lookup"><span data-stu-id="8dc27-110">To use the idle engine, clients and service providers create a callback function that contains the tasks that should occur when the MAPI subsystem is idle.</span></span> <span data-ttu-id="8dc27-111">Lorsque MAPI détecte le temps d’inactivité, il appelle cette fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="8dc27-111">When MAPI detects idle time, it invokes this callback function.</span></span> <span data-ttu-id="8dc27-112">La fonction de rappel suit le prototype **FNIDLE,** défini comme suit :</span><span class="sxs-lookup"><span data-stu-id="8dc27-112">The callback function follows the **FNIDLE** prototype, defined as follows:</span></span> 
  
 `BOOL (STDAPICALLTYPE FNIDLE) (LPVOID lpvContext)`
  
<span data-ttu-id="8dc27-113">Pour plus d’informations, [voir FNIDLE](fnidle.md).</span><span class="sxs-lookup"><span data-stu-id="8dc27-113">For more information, see [FNIDLE](fnidle.md).</span></span>
  
<span data-ttu-id="8dc27-114">Les fonctions qui font le moteur inactif sont :</span><span class="sxs-lookup"><span data-stu-id="8dc27-114">The functions that make up the idle engine are:</span></span>
  
[<span data-ttu-id="8dc27-115">ChangeIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="8dc27-115">ChangeIdleRoutine</span></span>](changeidleroutine.md)
  
[<span data-ttu-id="8dc27-116">DeregisterIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="8dc27-116">DeregisterIdleRoutine</span></span>](deregisteridleroutine.md)
  
[<span data-ttu-id="8dc27-117">EnableIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="8dc27-117">EnableIdleRoutine</span></span>](enableidleroutine.md)
  
[<span data-ttu-id="8dc27-118">FtgRegisterIdleRoutine</span><span class="sxs-lookup"><span data-stu-id="8dc27-118">FtgRegisterIdleRoutine</span></span>](ftgregisteridleroutine.md)
  
[<span data-ttu-id="8dc27-119">MAPIDeInitIdle</span><span class="sxs-lookup"><span data-stu-id="8dc27-119">MAPIDeInitIdle</span></span>](mapideinitidle.md)
  
[<span data-ttu-id="8dc27-120">MAPIInitIdle</span><span class="sxs-lookup"><span data-stu-id="8dc27-120">MAPIInitIdle</span></span>](mapiinitidle.md)
  
<span data-ttu-id="8dc27-121">Pour inscrire une fonction de rappel, les clients et les fournisseurs de services appellent la **fonction FtgRegisterIdleRoutine.**</span><span class="sxs-lookup"><span data-stu-id="8dc27-121">To register a callback function, clients and service providers call the **FtgRegisterIdleRoutine** function.</span></span> <span data-ttu-id="8dc27-122">Les paramètres d’entrée incluent une priorité facultative, un bloc de mémoire transmis à votre fonction de rappel en tant qu’entrée, une durée d’utilisation appropriée et un ensemble d’indicateurs d’option.</span><span class="sxs-lookup"><span data-stu-id="8dc27-122">The input parameters include an optional priority, a block of memory that is passed to your callback function as input, an amount of time to be used in any way appropriate, and a set of option flags.</span></span> 
  
<span data-ttu-id="8dc27-123">Les clients et les fournisseurs de services peuvent spécifier une priorité dans le paramètre  _priIdle_ qui contrôle le fonctionnement de la fonction inactive ou spécifier zéro si la priorité n’est pas un problème.</span><span class="sxs-lookup"><span data-stu-id="8dc27-123">Clients and service providers can specify a priority in the  _priIdle_ parameter that controls how the idle function runs or specify zero if priority is not an issue.</span></span> <span data-ttu-id="8dc27-124">Étant donné que les nombres négatifs représentent des priorités plus élevées que les nombres positifs ou zéro, les opérations de compression et de recherche doivent être affectées à des nombres négatifs.</span><span class="sxs-lookup"><span data-stu-id="8dc27-124">Because negative numbers represent higher priorities than positive numbers or zero, compression and search operations should be assigned negative numbers.</span></span> <span data-ttu-id="8dc27-125">Les tâches qui se produisent une seule fois doivent se faire attribuer des nombres positifs.</span><span class="sxs-lookup"><span data-stu-id="8dc27-125">Tasks that occur once should be assigned positive numbers.</span></span> 
  
<span data-ttu-id="8dc27-126">Pour désinsister une fonction de rappel active, les clients et les fournisseurs de services appellent la **fonction DeregisterIdleRoutine.**</span><span class="sxs-lookup"><span data-stu-id="8dc27-126">To deregister an active callback function, clients and service providers call the **DeregisterIdleRoutine** function.</span></span> <span data-ttu-id="8dc27-127">Étant donné que **DeregisterIdleRoutine** fonctionne de manière asynchrone, il est possible que la fonction de rappel soit invoquée à tout moment pendant l’appel de suppression d’register et même après le retour de **DeregisterIdleRoutine.**</span><span class="sxs-lookup"><span data-stu-id="8dc27-127">Because **DeregisterIdleRoutine** operates asynchronously, it is possible for the callback function to be invoked at any time during the deregister call and possibly even after **DeregisterIdleRoutine** has returned.</span></span> 
  
<span data-ttu-id="8dc27-128">Pour modifier une partie ou l’ensemble des caractéristiques d’une fonction de rappel, les clients et les fournisseurs de services appellent la **fonction ChangeIdleRoutine.**</span><span class="sxs-lookup"><span data-stu-id="8dc27-128">To modify some or all of the characteristics of a callback function, clients and service providers call the **ChangeIdleRoutine** function.</span></span> <span data-ttu-id="8dc27-129">**ChangeIdleRoutine** effectue des modifications en fonction de la façon dont le paramètre  _d’indicateurs est_ paramétré ; **ChangeIdleRoutine peut** modifier la fonction elle-même, sa priorité, son paramètre d’heure et son paramètre d’entrée.</span><span class="sxs-lookup"><span data-stu-id="8dc27-129">**ChangeIdleRoutine** makes changes according to how the flags parameter  _ircIdle_ is set; **ChangeIdleRoutine** can change the function itself, its priority, time setting, and input parameter.</span></span> 
  
<span data-ttu-id="8dc27-130">MAPI définit inactif de la même manière que le système d’exploitation, lorsque le système d’exploitation possède une définition.</span><span class="sxs-lookup"><span data-stu-id="8dc27-130">MAPI defines idle the same as the operating system, when the operating system has a definition.</span></span> <span data-ttu-id="8dc27-131">Sur Win32, MAPI crée un thread avec une priorité de classe inactive pour planifier les tâches inactives.</span><span class="sxs-lookup"><span data-stu-id="8dc27-131">On Win32, MAPI creates a thread with idle-class priority to schedule idle tasks.</span></span> <span data-ttu-id="8dc27-132">Ce thread effectue le suivi de l’heure et publie un message dans le thread qui consiste à exécuter la tâche inactive lorsque le moment de son exécution arrive.</span><span class="sxs-lookup"><span data-stu-id="8dc27-132">This thread keeps track of the time and posts a message to the thread that is to execute the idle task when the time for its execution arrives.</span></span> <span data-ttu-id="8dc27-133">Win32 programme les threads, et non les processus.</span><span class="sxs-lookup"><span data-stu-id="8dc27-133">Win32 schedules threads, not processes.</span></span> <span data-ttu-id="8dc27-134">Si des tâches dont la priorité est supérieure à la priorité d’inactivité se produisent sur la station de travail, la tâche inactive ne doit pas être programmée pour l’exécution tant que les tâches n’ont pas été terminées.</span><span class="sxs-lookup"><span data-stu-id="8dc27-134">If tasks that have a priority higher than the idle priority are occurring on the workstation, the idle task should not get scheduled for execution until the tasks have completed.</span></span> 
  
<span data-ttu-id="8dc27-135">Toutes les tâches inactives s’exécutent sur le thread qui a **appelé MAPIInitIdle**.</span><span class="sxs-lookup"><span data-stu-id="8dc27-135">All idle tasks run on the thread that called **MAPIInitIdle**.</span></span> <span data-ttu-id="8dc27-136">MAPI dispose d’un thread distinct pour la planification, mais lorsqu’une tâche inactive devient éligible, elle publie un message sur le thread d’initialisation et la tâche inactive y est exécutée.</span><span class="sxs-lookup"><span data-stu-id="8dc27-136">MAPI has a separate thread for scheduling, but when an idle task becomes eligible, it posts a message back over to the initialization thread and the idle task is executed there.</span></span> <span data-ttu-id="8dc27-137">Les implications pour les différents types de clients sont les suivantes.</span><span class="sxs-lookup"><span data-stu-id="8dc27-137">The implications for different types of clients are as follows.</span></span>
  
|<span data-ttu-id="8dc27-138">**Modèle de thread**</span><span class="sxs-lookup"><span data-stu-id="8dc27-138">**Threading model**</span></span>|<span data-ttu-id="8dc27-139">**Implication**</span><span class="sxs-lookup"><span data-stu-id="8dc27-139">**Implication**</span></span>|
|:-----|:-----|
|<span data-ttu-id="8dc27-140">Thread unique</span><span class="sxs-lookup"><span data-stu-id="8dc27-140">Single-threaded</span></span>  <br/> |<span data-ttu-id="8dc27-141">Pas de problème.</span><span class="sxs-lookup"><span data-stu-id="8dc27-141">No problem.</span></span> <span data-ttu-id="8dc27-142">Les fonctions inactives s’exécutent sur le thread principal de votre client et sont sérialisées via la boucle de message.</span><span class="sxs-lookup"><span data-stu-id="8dc27-142">Idle functions execute on your client's main thread and are serialized through the message loop.</span></span>  <br/> |
|<span data-ttu-id="8dc27-143">Thread libre</span><span class="sxs-lookup"><span data-stu-id="8dc27-143">Free-threaded</span></span>  <br/> |<span data-ttu-id="8dc27-144">Les fonctions inactives doivent être thread-safe, mais votre client dispose déjà de l’infrastructure nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8dc27-144">Idle functions must be thread-safe, but your client already has the necessary infrastructure.</span></span> <span data-ttu-id="8dc27-145">Votre client n’a peut-être pas besoin du moteur d’inactivité MAPI.</span><span class="sxs-lookup"><span data-stu-id="8dc27-145">Your client might not need the MAPI idle engine at all.</span></span>  <br/> |
|<span data-ttu-id="8dc27-146">Threads de threads de location</span><span class="sxs-lookup"><span data-stu-id="8dc27-146">Apartment-threaded</span></span>  <br/> |<span data-ttu-id="8dc27-147">La fonction inactive doit s’exécuter sur le thread qui l’a inscrite si elle souhaite utiliser MAPI, OLE ou toute autre interface COM.</span><span class="sxs-lookup"><span data-stu-id="8dc27-147">Idle function has to execute on the same thread that registered it if it wants to use MAPI, OLE, or any other COM interfaces.</span></span> <span data-ttu-id="8dc27-148">La manière la plus simple consiste à inscrire une fonction inactive avec MAPI qui publie un message sur le thread de droite et répartit la fonction inactive « réelle » directement à partir de la boucle de messages de ce thread.</span><span class="sxs-lookup"><span data-stu-id="8dc27-148">The most straightforward way is to register an idle function with MAPI that posts a message to the right thread and dispatch the "real" idle function directly from that thread's message loop.</span></span>  <br/> |
   

