---
title: Accès aux DLL dans Excel
manager: soliver
ms.date: 03/09/2015
ms.audience: Developer
ms.topic: overview
keywords:
- accessing dlls [excel 2007],DLLs [Excel 2007], accessing in Excel
localization_priority: Normal
ms.assetid: e2bfd6ea-efa3-45c1-a5b8-2ccb8650c6ab
description: 'S�applique �: Excel 2013�| Office 2013�| Visual Studio'
ms.openlocfilehash: bfb562b6bbe824124c6b5a691745d076720ee004
ms.sourcegitcommit: 9d60cd82b5413446e5bc8ace2cd689f683fb41a7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/11/2018
ms.locfileid: "19782130"
---
# <a name="access-dlls-in-excel"></a><span data-ttu-id="f1818-104">Accès aux DLL dans Excel</span><span class="sxs-lookup"><span data-stu-id="f1818-104">Access DLLs in Excel</span></span>

<span data-ttu-id="f1818-105">**S’applique à**: Excel 2013 | Office 2013 | Visual Studio</span><span class="sxs-lookup"><span data-stu-id="f1818-105">**Applies to**: Excel 2013 | Office 2013 | Visual Studio</span></span> 
  
<span data-ttu-id="f1818-106">Vous pouvez acc�der � une fonction ou commande DLL dans Microsoft�Excel de plusieurs fa�ons�:</span><span class="sxs-lookup"><span data-stu-id="f1818-106">You can access a DLL function or command in Microsoft Excel in several ways:</span></span>
  
- <span data-ttu-id="f1818-107">avec un module de code Microsoft�Visual�Basic pour Applications (VBA) dans lequel la fonction ou commande a �t� rendue disponible � l�aide d�une instruction **Declare**�;</span><span class="sxs-lookup"><span data-stu-id="f1818-107">Through a Microsoft Visual Basic for Applications (VBA) code module in which the function or command has been made available using a **Declare** statement.</span></span> 
    
- <span data-ttu-id="f1818-108">avec une feuille macro XLM � l�aide des fonctions **CALL** ou **REGISTER**�;</span><span class="sxs-lookup"><span data-stu-id="f1818-108">Through an XLM macro sheet by using the **CALL** or **REGISTER** functions.</span></span> 
    
- <span data-ttu-id="f1818-109">directement � partir de la feuille de calcul ou d�un �l�ment personnalis� dans l�interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="f1818-109">Directly from the worksheet or from a customized item in the user interface (UI).</span></span>
    
<span data-ttu-id="f1818-p101">Cette documentation ne couvre pas les fonctions XLM. Il est recommand� d�utiliser l�une des deux autres approches.</span><span class="sxs-lookup"><span data-stu-id="f1818-p101">This documentation does not cover XLM functions. It is recommended that you use either of the other two approaches.</span></span>
  
<span data-ttu-id="f1818-p102">Pour pouvoir acc�der � la fonction ou � la commande directement � partir de la feuille de calcul ou d�un �l�ment personnalis� dans l�interface utilisateur, elles doivent pr�alablement �tre inscrites aupr�s d�Excel. Pour plus d�informations sur l�inscription des commandes et des fonctions, voir [Acc�s au code XLL dans Excel (en anglais)](accessing-xll-code-in-excel.md).</span><span class="sxs-lookup"><span data-stu-id="f1818-p102">To be accessed directly from the worksheet or from a customized item in the UI, the function or command must first be registered with Excel. For information about registering commands and functions, see [Accessing XLL Code in Excel](accessing-xll-code-in-excel.md).</span></span>
  
## <a name="calling-dll-functions-and-commands-from-vba"></a><span data-ttu-id="f1818-114">Appel de fonctions DLL et les commandes à partir de VBA</span><span class="sxs-lookup"><span data-stu-id="f1818-114">Calling DLL functions and commands from VBA</span></span>

<span data-ttu-id="f1818-p103">Vous pouvez acc�der aux fonctions et commandes DLL dans VBA � l�aide de l�instruction **Declare**. Elle poss�de une syntaxe pour les commandes, et une syntaxe pour les fonctions.</span><span class="sxs-lookup"><span data-stu-id="f1818-p103">You can access DLL functions and commands in VBA by using the **Declare** statement. This statement has one syntax for commands and one for functions.</span></span> 
  
- <span data-ttu-id="f1818-117">**Syntaxe�1�: commandes**</span><span class="sxs-lookup"><span data-stu-id="f1818-117">**Syntax 1 - commands**</span></span>
    
  ```vb
  [Public | Private] Declare Sub name Lib "libname" [Alias "aliasname"] [([arglist])]
  ```

- <span data-ttu-id="f1818-118">**Syntaxe�2�: fonctions**</span><span class="sxs-lookup"><span data-stu-id="f1818-118">**Syntax 2 - functions**</span></span>
    
  ```vb
  [Public | Private] Declare Function name Lib "libname" [Alias "aliasname"] [([arglist])] [As type]
  ```

<span data-ttu-id="f1818-p104">Les mots cl�s facultatifs **Public** et **Private** indiquent la port�e de la fonction import�e, respectivement l�ensemble du projet Visual�Basic ou le module Visual�Basic. Le nom est celui que vous souhaitez utiliser dans le code VBA. S�il est diff�rent du nom dans DLL, vous devez utiliser le sp�cificateur Alias ��aliasname��, et vous devez indiquer le nom de la fonction comme export� par DLL. Si vous souhaitez acc�der � une fonction DLL en r�f�rence � un nombre ordinal DLL, vous devez fournir un nom d�alias, autrement dit l�ordinal pr�fix� par **#**.</span><span class="sxs-lookup"><span data-stu-id="f1818-p104">The optional **Public** and **Private** keywords specify the scope of the imported function: the entire Visual Basic project or just the Visual Basic module, respectively. The name is the name that you want to use in the VBA code. If this differs from the name in the DLL, you must use the Alias "aliasname" specifier, and you should give the name of the function as exported by the DLL. If you want to access a DLL function by reference to a DLL ordinal number, you must provide an alias name, which is the ordinal prefixed by **#**.</span></span>
  
<span data-ttu-id="f1818-p105">Les commandes doivent renvoyer **void**. Les fonctions doivent renvoyer des types que VBA peut reconna�tre, **ByVal**. Cela signifie que certains types sont renvoy�s plus facilement en modifiant les arguments en place�: cha�nes, tableaux, types d�finis par l�utilisateur et objets.</span><span class="sxs-lookup"><span data-stu-id="f1818-p105">Commands should return **void**. Functions should return types that VBA can recognize **ByVal**. This means that some types are more easily returned by modifying arguments in place: strings, arrays, user-defined types, and objects.</span></span>
  
> [!NOTE]
> <span data-ttu-id="f1818-p106">[!REMARQUE] VBA ne peut pas v�rifier que la liste d�arguments et que le renvoi indiqu� dans le module Visual�Basic sont les m�mes que ceux cod�s dans DLL. Vous devez v�rifier cet �l�ment vous-m�me tr�s attentivement, car une erreur peut provoquer un incident d�Excel.</span><span class="sxs-lookup"><span data-stu-id="f1818-p106">VBA cannot check that the argument list and return stated in the Visual Basic module are the same as coded in the DLL. You should check this yourself very carefully, because a mistake could cause Excel to crash.</span></span> 
  
<span data-ttu-id="f1818-p107">Lorsque les arguments de la fonction ou de la commande ne sont pas transmis par r�f�rence ou pointeur, ils doivent �tre pr�c�d�s du mot cl� **ByVal** dans la d�claration **arglist**. Lorsqu�une fonction C/C++ prend des arguments de pointeur, ou qu�une fonction C++ prend des arguments de r�f�rence, ils doivent �tre transmis **ByRef**. Le mot cl� **ByRef** peut �tre omis des listes d�arguments, car il s�agit de la valeur par d�faut dans VBA.</span><span class="sxs-lookup"><span data-stu-id="f1818-p107">When the function or command's arguments are not passed by reference or pointer, they must be preceded by the **ByVal** keyword in the **arglist** declaration. When a C/C++ function takes pointer arguments, or a C++ function takes reference arguments, they should be passed **ByRef**. The keyword **ByRef** can be omitted from argument lists because it is the default in VBA.</span></span> 
  
### <a name="argument-types-in-cc-and-vba"></a><span data-ttu-id="f1818-131">Types d’argument dans C/C++ et VBA</span><span class="sxs-lookup"><span data-stu-id="f1818-131">Argument types in C/C++ and VBA</span></span>

<span data-ttu-id="f1818-132">Vous devez prendre notre des �l�ments suivants lorsque vous comparez les d�clarations de types d�arguments dans C/C++ et VBA.</span><span class="sxs-lookup"><span data-stu-id="f1818-132">You should note the following when you compare the declarations of argument types in C/C++ and VBA.</span></span>
  
- <span data-ttu-id="f1818-133">Un �l�ment **String** VBA est transmis comme pointeur vers une structure BSTR de cha�ne d�octets lorsqu�il est transmis ByVal, et comme pointeur vers un pointeur lorsqu�il est transmis **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="f1818-133">A VBA **String** is passed as a pointer to a byte-string BSTR structure when passed ByVal, and as a pointer to a pointer when passed **ByRef**.</span></span>
    
- <span data-ttu-id="f1818-134">Un �l�ment **Variant** VBA contenant une cha�ne est transmis comme pointeur vers une structure BSTR de cha�ne de caract�res larges lorsqu�il est transmis **ByVal**, et comme un pointeur vers un pointeur lorsqu�il est transmis **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="f1818-134">A VBA **Variant** that contains a string is passed as a pointer to a Unicode wide-character string BSTR structure when passed **ByVal**, and as a pointer to a pointer when passed **ByRef**.</span></span>
    
- <span data-ttu-id="f1818-135">L��l�ment **Integer** VBA est un type de 16�bits �quivalent � un �l�ment signed short dans C/C++.</span><span class="sxs-lookup"><span data-stu-id="f1818-135">The VBA **Integer** is a 16-bit type equivalent to a signed short in C/C++.</span></span> 
    
- <span data-ttu-id="f1818-136">L��l�ment **Long** VBA est un type de 32�bits �quivalent � un �l�ment signed int dans C/C++.</span><span class="sxs-lookup"><span data-stu-id="f1818-136">The VBA **Long** is a 32-bit type equivalent to a signed int in C/C++.</span></span> 
    
- <span data-ttu-id="f1818-137">VBA et C/C++ permettent de d�finir des types de donn�es d�finis par l�utilisateur, � l�aide des instructions **Type** et **struct**, respectivement.</span><span class="sxs-lookup"><span data-stu-id="f1818-137">Both VBA and C/C++ allow the definition of user-defined data types, using the **Type** and **struct** statements respectively.</span></span> 
    
- <span data-ttu-id="f1818-138">VBA et C/C++ prennent en charge le type de donn�es **Variant**, d�fini pour C/C++ dans les fichiers d�en-t�te OLE/COM Windows en tant que VARIANT.</span><span class="sxs-lookup"><span data-stu-id="f1818-138">Both VBA and C/C++ support the **Variant** data type, defined for C/C++ in the Windows OLE/COM header files as VARIANT.</span></span> 
    
- <span data-ttu-id="f1818-139">Les tableaux VBA sont des �l�ments **SafeArrays** OLE d�finis pour C/C++ dans les fichiers d�en-t�te OLE/COM Windows en tant que **SAFEARRAY**.</span><span class="sxs-lookup"><span data-stu-id="f1818-139">VBA arrays are OLE **SafeArrays**, defined for C/C++ in the Windows OLE/COM header files as **SAFEARRAY**.</span></span>
    
- <span data-ttu-id="f1818-140">Le type de donn�es VBA **Currency** est transmis comme une structure de type **CY**, d�finie dans le fichier d�en-t�te Windows wtypes.h lorsqu�il est transmis **ByVal**, et comme un pointeur vers cet �l�ment lorsqu�il est transmis **ByRef**.</span><span class="sxs-lookup"><span data-stu-id="f1818-140">The VBA **Currency** data type is passed as a structure of type **CY**, defined in the Windows header file wtypes.h, when passed **ByVal**, and as a pointer to this when passed **ByRef**.</span></span>
    
<span data-ttu-id="f1818-141">Dans VBA, les �l�ments de donn�es dans les types de donn�es d�finis par l�utilisateur sont compress�s aux limites de 4�octets, tandis que dans Visual�Studio, par d�faut, ils sont compress�s aux limites de 8�octets.</span><span class="sxs-lookup"><span data-stu-id="f1818-141">In VBA, data elements in user-defined data types are packed to 4-byte boundaries, whereas in Visual Studio, by default, they are packed to 8-byte boundaries.</span></span> <span data-ttu-id="f1818-142">Par conséquent, vous devez placer la définition de la structure C/C++ dans une `#pragma pack(4) … #pragma pack()` bloc afin d’éviter les éléments alignés.</span><span class="sxs-lookup"><span data-stu-id="f1818-142">Therefore you must enclose the C/C++ structure definition in a `#pragma pack(4) … #pragma pack()` block to avoid elements being misaligned.</span></span> 
  
<span data-ttu-id="f1818-143">Voici un exemple de d�finitions de type utilisateur �quivalentes.</span><span class="sxs-lookup"><span data-stu-id="f1818-143">The following is an example of equivalent user type definitions.</span></span>
  
```vb
Type VB_User_Type
    i As Integer
    d As Double
    s As String
End Type

```

```cpp
#pragma pack(4)
struct C_user_type
{
    short iVal;
    double dVal;
    BSTR bstr; // VBA String type is a byte string
}
#pragma pack() // restore default

```

<span data-ttu-id="f1818-p109">Dans certains cas, VBA prend en charge une plage de valeurs plus grande qu�Excel. Le double de VBA est compatible IEEE, et prend en charge des num�ros inf�rieurs � la normale qui sont arrondis � z�ro sur la feuille de calcul. Le type **Date** VBA peut repr�senter des dates comme 1-Jan-0100 � l�aide de dates s�rialis�es n�gatives. Excel autorise uniquement les dates s�rialis�es sup�rieures ou �gales � z�ro. Le type **Currency** VBA (un nombre de 64�bits mis � l��chelle) peut atteindre une pr�cision non prise en charge par les doubles de 8�octets, et n�est donc pas mis en correspondance dans la feuille de calcul.</span><span class="sxs-lookup"><span data-stu-id="f1818-p109">VBA supports a greater range of values in some cases than Excel supports. The VBA double is IEEE compliant, supporting subnormal numbers that are currently rounded down to zero on the worksheet. The VBA **Date** type can represent dates as early as 1-Jan-0100 using negative serialized dates. Excel only allows serialized dates greater than or equal to zero. The VBA **Currency** type—a scaled 64-bit integer—can achieve accuracy not supported in 8-byte doubles, and so is not matched in the worksheet.</span></span> 
  
<span data-ttu-id="f1818-149">Excel transmet uniquement des variantes des types suivants � une fonction d�finie par l�utilisateur VBA.</span><span class="sxs-lookup"><span data-stu-id="f1818-149">Excel only passes Variants of the following types to a VBA user-defined function.</span></span>
  
|<span data-ttu-id="f1818-150">**Type de donn�es VBA**</span><span class="sxs-lookup"><span data-stu-id="f1818-150">**VBA data type**</span></span>|<span data-ttu-id="f1818-151">**Indicateurs binaires de type Variant C/C++**</span><span class="sxs-lookup"><span data-stu-id="f1818-151">**C/C++ Variant type bit flags**</span></span>|<span data-ttu-id="f1818-152">**Description**</span><span class="sxs-lookup"><span data-stu-id="f1818-152">**Description**</span></span>|
|:-----|:-----|:-----|
|<span data-ttu-id="f1818-153">Double</span><span class="sxs-lookup"><span data-stu-id="f1818-153">Double</span></span>  <br/> |<span data-ttu-id="f1818-154">**VT_R8**</span><span class="sxs-lookup"><span data-stu-id="f1818-154">**VT_R8**</span></span> <br/> ||
|<span data-ttu-id="f1818-155">Bool�en</span><span class="sxs-lookup"><span data-stu-id="f1818-155">Boolean</span></span>  <br/> |<span data-ttu-id="f1818-156">**VT_BOOL**</span><span class="sxs-lookup"><span data-stu-id="f1818-156">**VT_BOOL**</span></span> <br/> ||
|<span data-ttu-id="f1818-157">Date</span><span class="sxs-lookup"><span data-stu-id="f1818-157">Date</span></span>  <br/> |<span data-ttu-id="f1818-158">**VT_DATE**</span><span class="sxs-lookup"><span data-stu-id="f1818-158">**VT_DATE**</span></span> <br/> ||
|<span data-ttu-id="f1818-159">String</span><span class="sxs-lookup"><span data-stu-id="f1818-159">String</span></span>  <br/> |<span data-ttu-id="f1818-160">**VT_BSTR**</span><span class="sxs-lookup"><span data-stu-id="f1818-160">**VT_BSTR**</span></span> <br/> |<span data-ttu-id="f1818-161">Cha�ne d�octets BSTR OLE</span><span class="sxs-lookup"><span data-stu-id="f1818-161">OLE Bstr byte string</span></span>  <br/> |
|<span data-ttu-id="f1818-162">Plage</span><span class="sxs-lookup"><span data-stu-id="f1818-162">Range</span></span>  <br/> |<span data-ttu-id="f1818-163">**VT_DISPATCH**</span><span class="sxs-lookup"><span data-stu-id="f1818-163">**VT_DISPATCH**</span></span> <br/> |<span data-ttu-id="f1818-164">R�f�rences de plage et de cellule</span><span class="sxs-lookup"><span data-stu-id="f1818-164">Range and cell references</span></span>  <br/> |
|<span data-ttu-id="f1818-165">Variant contenant un tableau</span><span class="sxs-lookup"><span data-stu-id="f1818-165">Variant containing an array</span></span>  <br/> |<span data-ttu-id="f1818-166">**VT_ARRAY**</span><span class="sxs-lookup"><span data-stu-id="f1818-166">**VT_ARRAY**</span></span> | <span data-ttu-id="f1818-167">**VT_VARIANT**</span><span class="sxs-lookup"><span data-stu-id="f1818-167">**VT_VARIANT**</span></span> <br/> |<span data-ttu-id="f1818-168">Tableaux de type litt�ral</span><span class="sxs-lookup"><span data-stu-id="f1818-168">Literal arrays</span></span>  <br/> |
|<span data-ttu-id="f1818-169">Ccy</span><span class="sxs-lookup"><span data-stu-id="f1818-169">Ccy</span></span>  <br/> |<span data-ttu-id="f1818-170">**VT_CY**</span><span class="sxs-lookup"><span data-stu-id="f1818-170">**VT_CY**</span></span> <br/> |<span data-ttu-id="f1818-171">Nombre entier de 64�bits mis � l��chelle pour autoriser 4�d�cimales de pr�cision.</span><span class="sxs-lookup"><span data-stu-id="f1818-171">64-bit integer scaled to permit 4 decimal places of accuracy.</span></span>  <br/> |
|<span data-ttu-id="f1818-172">Variant contenant une erreur</span><span class="sxs-lookup"><span data-stu-id="f1818-172">Variant containing an error</span></span>  <br/> |<span data-ttu-id="f1818-173">**VT_ERROR**</span><span class="sxs-lookup"><span data-stu-id="f1818-173">**VT_ERROR**</span></span> <br/> ||
||<span data-ttu-id="f1818-174">**VT_EMPTY**</span><span class="sxs-lookup"><span data-stu-id="f1818-174">**VT_EMPTY**</span></span> <br/> |<span data-ttu-id="f1818-175">Cellules vides ou arguments omis</span><span class="sxs-lookup"><span data-stu-id="f1818-175">Empty cells or omitted arguments</span></span>  <br/> |
   
<span data-ttu-id="f1818-p110">Vous pouvez v�rifier le type d�un �l�ment Variant transmis dans VBA � l�aide de **VarType**, sauf que la fonction renvoie le type des valeurs de la plage lorsqu�elle est appel�e avec des r�f�rences. Pour d�terminer si un �l�ment **Variant** est un objet de r�f�rence **Range**, vous pouvez utiliser la fonction **IsObject**.</span><span class="sxs-lookup"><span data-stu-id="f1818-p110">You can check the type of a passed-in Variant in VBA using the **VarType**, except that the function returns the type of the range's values when called with references. To determine if a **Variant** is a **Range** reference object, you can use the **IsObject** function.</span></span> 
  
<span data-ttu-id="f1818-p111">Vous pouvez cr�er des �l�ments **Variants** qui contiennent des tableaux de variantes dans VBA � partir d�un �l�ment **Range** en affectant sa propri�t� **Value** � un �l�ment **Variant**. Toutes les cellules de la plage source qui sont mises en forme � l�aide du format de devise standard pour les param�tres r�gionaux en vigueur � ce moment-l� sont converties en �l�ments de tableau de type **Currency**. Toutes les cellules mises en forme en tant que dates sont converties en �l�ments de tableau de type **Date**. Les cellules contenant des cha�nes sont converties en variantes **BSTR** � caract�res larges. Les cellules contenant des erreurs sont converties en �l�ments **Variants** de type **VT_ERROR**. Les cellules contenant les valeurs **Boolean** **True** ou **False** sont converties en �l�ments **Variants** de type **VT_BOOL**.</span><span class="sxs-lookup"><span data-stu-id="f1818-p111">You can create **Variants** that contain arrays of variants in VBA from a **Range** by assigning its **Value** property to a **Variant**. Any cells in the source range that are formatted using the standard currency format for the regional settings in force at the time are converted to array elements of type **Currency**. Any cells formatted as dates are converted to array elements of type **Date**. Cells containing strings are converted to wide-character **BSTR** Variants. Cells containing errors are converted to **Variants** of type **VT_ERROR**. Cells containing **Boolean** **True** or **False** are converted to **Variants** of type **VT_BOOL**.</span></span> 
  
> [!NOTE]
> <span data-ttu-id="f1818-p112">[!REMARQUE] L��l�ment **Variant** stocke **True** comme -1 et **False** comme 0. Les nombres non mis en forme en tant que dates ou montants en devise sont convertis en variantes de type **VT_R8**.</span><span class="sxs-lookup"><span data-stu-id="f1818-p112">The **Variant** stores **True** as -1 and **False** as 0. Numbers not formatted as dates or currency amounts are converted to Variants of type **VT_R8**.</span></span> 
  
### <a name="variant-and-string-arguments"></a><span data-ttu-id="f1818-186">Arguments de type Variant et de chaîne</span><span class="sxs-lookup"><span data-stu-id="f1818-186">Variant and string arguments</span></span>

<span data-ttu-id="f1818-p113">Excel utilise en interne des cha�nes Unicode � caract�res larges. Lorsqu�une fonction d�finie par l�utilisateur VBA est d�clar�e comme prenant un argument **String**, Excel convertit la cha�ne fournie en une cha�ne d�octets d�une mani�re propre aux param�tres r�gionaux. Si vous souhaitez que votre fonction soit transmise � une cha�ne Unicode, votre fonction d�finie par l�utilisateur VBA doit accepter un argument **Variant** au lieu d�un argument **String**. Votre fonction DLL peut ensuite accepter la cha�ne � caract�res larges BSTR **Variant** � partir de VBA.</span><span class="sxs-lookup"><span data-stu-id="f1818-p113">Excel works internally with wide-character Unicode strings. When a VBA user-defined function is declared as taking a **String** argument, Excel converts the supplied string to a byte-string in a locale-specific way. If you want your function to be passed a Unicode string, your VBA user-defined function should accept a **Variant** instead of a **String** argument. Your DLL function can then accept that **Variant** BSTR wide-character string from VBA.</span></span> 
  
<span data-ttu-id="f1818-p114">Pour renvoyer des cha�nes Unicode � VBA � partir d�une DLL, vous devez modifier un argument de cha�ne de type **Variant** en place. Pour ce faire, vous devez d�clarer la fonction DLL comme prenant un pointeur vers l��l�ment **Variant** et dans votre code C/C++, et d�clarer l�argument dans le code VBA comme  `ByRef varg As Variant`. La m�moire de l�ancienne cha�ne doit �tre lib�r�e, et la nouvelle valeur de cha�ne cr��e � l�aide de la cha�ne BSTR OLE ne fonctionne que dans la DLL.</span><span class="sxs-lookup"><span data-stu-id="f1818-p114">To return Unicode strings to VBA from a DLL, you should modify a **Variant** string argument in place. For this to work, you must declare the DLL function as taking a pointer to the **Variant** and in your C/C++ code, and declare the argument in the VBA code as  `ByRef varg As Variant`. The old string memory should be released, and the new string value created by using the OLE Bstr string functions only in the DLL.</span></span>
  
<span data-ttu-id="f1818-p115">Pour renvoyer une cha�ne d�octets � VBA � partir d�une DLL, vous devez modifier un argument BSTR de cha�ne d�octets en place. Pour ce faire, vous devez d�clarer la fonction DLL comme prenant un pointeur vers un pointeur vers l��l�ment BSTR et dans votre code C/C++, et d�clarer l�argument dans le code VBA comme **ByRef varg As String**�.</span><span class="sxs-lookup"><span data-stu-id="f1818-p115">To return a byte string to VBA from a DLL, you should modify a byte-string BSTR argument in place. For this to work, you must declare the DLL function as taking a pointer to a pointer to the BSTR and in your C/C++ code, and declare the argument in the VBA code as ' **ByRef varg As String**'.</span></span>
  
<span data-ttu-id="f1818-p116">Vous devez g�rer uniquement les cha�nes qui sont transmises de ces fa�ons � partir de VBA � l�aide des fonctions de cha�ne BSTR OLE pour �viter les probl�mes li�s � la m�moire. Par exemple, vous devez appeler **SysFreeString** pour lib�rer de la m�moire avant de remplacer la cha�ne transmise, et **SysAllocStringByteLen** ou **SysAllocStringLen** pour allouer de l�espace � une nouvelle cha�ne.</span><span class="sxs-lookup"><span data-stu-id="f1818-p116">You should only handle strings that are passed in these ways from VBA using the OLE BSTR string functions to avoid memory-related problems. For example, you must call **SysFreeString** to free the memory before overwriting the passed in string, and **SysAllocStringByteLen** or **SysAllocStringLen** to allocate space for a new string.</span></span> 
  
<span data-ttu-id="f1818-p117">Vous pouvez cr�er des erreurs de feuille de calcul Excel en tant que **Variants** dans VBA � l�aide de la fonction **CVerr** avec des arguments, comme indiqu� dans le tableau suivant. Les erreurs de feuille de calcul peuvent �galement �tre renvoy�es � VBA � partir d�une DLL � l�aide d��l�ments **Variants** de type **VT_ERROR**, et avec les valeurs suivantes dans le champ **ulVal**.</span><span class="sxs-lookup"><span data-stu-id="f1818-p117">You can create Excel worksheet errors as **Variants** in VBA by using the **CVerr** function with arguments as shown in the following table. Worksheet errors can also be returned to VBA from a DLL using **Variants** of type **VT_ERROR**, and with the following values in the **ulVal** field.</span></span> 
  
|<span data-ttu-id="f1818-200">**Erreur**</span><span class="sxs-lookup"><span data-stu-id="f1818-200">**Error**</span></span>|<span data-ttu-id="f1818-201">**Valeur de type Variant ulVal**</span><span class="sxs-lookup"><span data-stu-id="f1818-201">**Variant ulVal value**</span></span>|<span data-ttu-id="f1818-202">**Argument CVerr**</span><span class="sxs-lookup"><span data-stu-id="f1818-202">**CVerr argument**</span></span>|
|:-----|:-----|:-----|
|<span data-ttu-id="f1818-203">#NULL!</span><span class="sxs-lookup"><span data-stu-id="f1818-203">#NULL!</span></span>  <br/> |<span data-ttu-id="f1818-204">2148141008</span><span class="sxs-lookup"><span data-stu-id="f1818-204">2148141008</span></span>  <br/> |<span data-ttu-id="f1818-205">2000</span><span class="sxs-lookup"><span data-stu-id="f1818-205">2000</span></span>  <br/> |
|<span data-ttu-id="f1818-206">#DIV/0!</span><span class="sxs-lookup"><span data-stu-id="f1818-206">#DIV/0!</span></span>  <br/> |<span data-ttu-id="f1818-207">2148141015</span><span class="sxs-lookup"><span data-stu-id="f1818-207">2148141015</span></span>  <br/> |<span data-ttu-id="f1818-208">2007</span><span class="sxs-lookup"><span data-stu-id="f1818-208">2007</span></span>  <br/> |
|<span data-ttu-id="f1818-209">#VALUE!</span><span class="sxs-lookup"><span data-stu-id="f1818-209">#VALUE!</span></span>  <br/> |<span data-ttu-id="f1818-210">2148141023</span><span class="sxs-lookup"><span data-stu-id="f1818-210">2148141023</span></span>  <br/> |<span data-ttu-id="f1818-211">2015</span><span class="sxs-lookup"><span data-stu-id="f1818-211">2015</span></span>  <br/> |
|<span data-ttu-id="f1818-212">#REF!</span><span class="sxs-lookup"><span data-stu-id="f1818-212">#REF!</span></span>  <br/> |<span data-ttu-id="f1818-213">2148141031</span><span class="sxs-lookup"><span data-stu-id="f1818-213">2148141031</span></span>  <br/> |<span data-ttu-id="f1818-214">2023</span><span class="sxs-lookup"><span data-stu-id="f1818-214">2023</span></span>  <br/> |
|<span data-ttu-id="f1818-215">#NAME?</span><span class="sxs-lookup"><span data-stu-id="f1818-215">#NAME?</span></span>  <br/> |<span data-ttu-id="f1818-216">2148141037</span><span class="sxs-lookup"><span data-stu-id="f1818-216">2148141037</span></span>  <br/> |<span data-ttu-id="f1818-217">2029</span><span class="sxs-lookup"><span data-stu-id="f1818-217">2029</span></span>  <br/> |
|<span data-ttu-id="f1818-218">#NUM!</span><span class="sxs-lookup"><span data-stu-id="f1818-218">#NUM!</span></span>  <br/> |<span data-ttu-id="f1818-219">2148141044</span><span class="sxs-lookup"><span data-stu-id="f1818-219">2148141044</span></span>  <br/> |<span data-ttu-id="f1818-220">2036</span><span class="sxs-lookup"><span data-stu-id="f1818-220">2036</span></span>  <br/> |
|<span data-ttu-id="f1818-221">#N/A</span><span class="sxs-lookup"><span data-stu-id="f1818-221">#N/A</span></span>  <br/> |<span data-ttu-id="f1818-222">2148141050</span><span class="sxs-lookup"><span data-stu-id="f1818-222">2148141050</span></span>  <br/> |<span data-ttu-id="f1818-223">2042</span><span class="sxs-lookup"><span data-stu-id="f1818-223">2042</span></span>  <br/> |
   
<span data-ttu-id="f1818-224">Notez que la valeur de type Variant **ulVal** donn�e est �quivalente � la valeur d�argument **CVerr** plus la valeur hexad�cimale x800A0000.</span><span class="sxs-lookup"><span data-stu-id="f1818-224">Note that the Variant **ulVal** value given is equivalent to the **CVerr** argument value plus x800A0000 hexadecimal.</span></span> 
  
## <a name="calling-dll-functions-directly-from-the-worksheet"></a><span data-ttu-id="f1818-225">Appeler des fonctions DLL directement à partir de la feuille de calcul</span><span class="sxs-lookup"><span data-stu-id="f1818-225">Calling DLL functions directly from the worksheet</span></span>

<span data-ttu-id="f1818-p118">Vous ne pouvez pas acc�der aux fonctions DLL�Win32 � partir de la feuille de calcul sans, par exemple, utiliser VBA ou XLM comme interfaces, ou sans informer Excel � l�avance de la fonction, de ses arguments et de son type de renvoi. Le processus de cette op�ration est appel� l�inscription.</span><span class="sxs-lookup"><span data-stu-id="f1818-p118">You cannot access Win32 DLL functions from the worksheet without, for example, using VBA or XLM as interfaces, or without letting Excel know about the function, its arguments, and its return type in advance. The process of doing this is called registration.</span></span>
  
<span data-ttu-id="f1818-228">Vous pouvez acc�der aux fonctions d�une DLL dans la feuille de calcul � l�aide des m�thodes suivantes�:</span><span class="sxs-lookup"><span data-stu-id="f1818-228">The ways in which the functions of a DLL can be accessed in the worksheet are as follows:</span></span>
  
- <span data-ttu-id="f1818-229">d�clarez la fonction dans VBA comme d�crit pr�c�demment, et acc�dez-y via une fonction d�finie par l�utilisateur VBA�;</span><span class="sxs-lookup"><span data-stu-id="f1818-229">Declare the function in VBA as described previously and access it via a VBA user-defined function.</span></span>
    
- <span data-ttu-id="f1818-230">appelez la fonction DLL � l�aide de l��l�ment CALL sur une feuille macro XLM, et acc�dez-y via une fonction d�finie par l�utilisateur XML�;</span><span class="sxs-lookup"><span data-stu-id="f1818-230">Call the DLL function using CALL on an XLM macro sheet, and access it via an XLM user-defined function.</span></span>
    
- <span data-ttu-id="f1818-231">utilisez une commande XML ou VBA pour appeler la fonction **REGISTER** XML, qui fournit les informations dont Excel a besoin pour reconna�tre la fonction lorsqu�elle est saisie dans une cellule de feuille de calcul�;</span><span class="sxs-lookup"><span data-stu-id="f1818-231">Use an XLM or VBA command to call the XLM **REGISTER** function, which provides the information that Excel needs to recognize the function when it is entered into a worksheet cell.</span></span> 
    
- <span data-ttu-id="f1818-232">transformez la DLL en un �l�ment XLL et inscrivez la fonction � l�aide de la fonction **xlfRegister** d�API�C lorsque XLL est activ�.</span><span class="sxs-lookup"><span data-stu-id="f1818-232">Turn the DLL into an XLL and register the function using the C API **xlfRegister** function when the XLL is activated.</span></span> 
    
<span data-ttu-id="f1818-p119">La quatri�me approche est autonome�: le code qui inscrit les fonctions et le code de fonction sont contenus dans le m�me projet de code. Le fait d�apporter des modifications au compl�ment n�implique pas la modification d�une feuille XML ou d�un module de code VBA. Pour proc�der de fa�on organis�e tout en restant dans le cadre des fonctionnalit�s de l�API�C, vous devez convertir votre DLL en un �l�ment XLL, et charger le compl�ment obtenu � l�aide du gestionnaire de compl�ments. Cela permet � Excel d�appeler une fonction que votre DLL expose lorsque le compl�ment est charg� ou activ�. � partir de cette �tape, vous pouvez enregistrer toutes les fonctions que contient votre XLL et ex�cuter toute autre initialisation DLL.</span><span class="sxs-lookup"><span data-stu-id="f1818-p119">The fourth approach is self-contained: the code that registers the functions and the function code are both contained in the same code project. Making changes to the add-in does not involve making changes to an XLM sheet or to a VBA code module. To do this in a well-managed way while still staying within the capabilities of the C API, you must turn your DLL into an XLL and load the resulting add-in by using the Add-in Manager. This enables Excel to call a function that your DLL exposes when the add-in is loaded or activated, from which you can register all of the functions your XLL contains, and carry out any other DLL initialization.</span></span>
  
## <a name="calling-dll-commands-directly-from-excel"></a><span data-ttu-id="f1818-237">Appeler des commandes DLL directement à partir d’Excel</span><span class="sxs-lookup"><span data-stu-id="f1818-237">Calling DLL commands directly from Excel</span></span>

<span data-ttu-id="f1818-238">Les commandes DLL�Win32 ne sont pas accessibles directement � partir des menus et bo�tes de dialogue Excel sans avoir une interface, telle que VBA, ou sans avoir inscrit les commandes � l�avance.</span><span class="sxs-lookup"><span data-stu-id="f1818-238">Win32 DLL commands are not accessible directly from Excel dialog boxes and menus without there being an interface, such as VBA, or without the commands being registered in advance.</span></span>
  
<span data-ttu-id="f1818-239">Vous pouvez acc�der aux commandes d�une DLL � l�aide des m�thodes suivantes�:</span><span class="sxs-lookup"><span data-stu-id="f1818-239">The ways in which you can access the commands of a DLL are as follows:</span></span>
  
- <span data-ttu-id="f1818-240">d�clarez la commande dans VBA comme d�crit pr�c�demment, et acc�dez-y via une macro VBA�;</span><span class="sxs-lookup"><span data-stu-id="f1818-240">Declare the command in VBA as described previously and access it via a VBA macro.</span></span>
    
- <span data-ttu-id="f1818-241">appelez la commande DLL � l�aide de l��l�ment **CALL** sur une feuille macro XLM, et acc�dez-y via une macro XML�;</span><span class="sxs-lookup"><span data-stu-id="f1818-241">Call the DLL command using **CALL** on an XLM macro sheet, and access it via an XLM macro.</span></span> 
    
- <span data-ttu-id="f1818-242">utilisez une commande XML ou VBA pour appeler la fonction **REGISTER** XML, qui fournit les informations dont Excel a besoin pour reconna�tre la commande lorsqu�elle est saisie dans une bo�te de dialogue qui attend le nom d�une commande de macro�;</span><span class="sxs-lookup"><span data-stu-id="f1818-242">Use an XLM or VBA command to call the XLM **REGISTER** function, which provides the information Excel needs to recognize the command when it is entered into a dialog box that expects the name of a macro command.</span></span> 
    
- <span data-ttu-id="f1818-243">transformez la DLL en un �l�ment XLL et inscrivez la commande � l�aide de la fonction **xlfRegister** d�API�C.</span><span class="sxs-lookup"><span data-stu-id="f1818-243">Turn the DLL into an XLL and register the command using the C API **xlfRegister** function.</span></span> 
    
<span data-ttu-id="f1818-p120">Comme expliqu� plus haut dans le contexte des fonctions DLL, la quatri�me approche est la plus autonome, et conserve le code d�inscription proche du code de la commande. Pour r�aliser cette action, vous devez convertir votre DLL en un �l�ment XLL et charger le compl�ment obtenu � l�aide du gestionnaire de compl�ments. Le fait d�inscrire des commandes de cette fa�on vous permet �galement d�attacher la commande � un �l�ment de l�interface utilisateur, tel qu�un menu personnalis�, ou de configurer une interruption d��v�nement qui appelle la commande suite � une combinaison de touches donn�e ou � un autre �v�nement.</span><span class="sxs-lookup"><span data-stu-id="f1818-p120">As discussed earlier in the context of DLL functions, the fourth approach is the most self-contained, keeping the registration code close to the command code. To do this, you must turn your DLL into an XLL and load the resulting add-in using the Add-in Manager. Registering commands in this way also lets you attach the command to an element of the user interface, such as a custom menu, or to set up an event trap that calls the command on a given keystroke or other event.</span></span>
  
<span data-ttu-id="f1818-247">Toutes les commandes XLL inscrites aupr�s d�Excel sont consid�r�es comme �tant au format suivant.</span><span class="sxs-lookup"><span data-stu-id="f1818-247">All XLL commands that are registered with Excel are assumed by Excel to be of the following form.</span></span>
  
```cpp
int WINAPI my_xll_cmd(void)
{
// Function code...
    return 1;
}
```

> [!NOTE]
> <span data-ttu-id="f1818-p121">[!REMARQUE] Excel ignore la valeur de renvoi, sauf si elle est appel�e � partir d�une feuille macro XLM, auquel cas la valeur de retour est convertie en **TRUE** ou **FALSE**. Vous devez par cons�quent renvoyer 1 si votre commande a �t� ex�cut�e correctement, et 0 si elle a �chou� ou a �t� annul�e par l�utilisateur.</span><span class="sxs-lookup"><span data-stu-id="f1818-p121">Excel ignores the return value unless it is called from an XLM macro sheet, in which case the return value is converted to **TRUE** or **FALSE**. You should therefore return 1 if your command executed successfully, and 0 if it failed or was canceled by the user.</span></span> 
  
## <a name="dll-memory-and-multiple-dll-instances"></a><span data-ttu-id="f1818-250">DLL de mémoire et plusieurs instances DLL</span><span class="sxs-lookup"><span data-stu-id="f1818-250">DLL memory and multiple DLL instances</span></span>

<span data-ttu-id="f1818-p122">Lorsqu�une application charge une DLL, le code ex�cutable de la DLL est charg� dans le segment de m�moire global afin que vous puissiez l�ex�cuter, et de l�espace est allou� sur le segment de m�moire global pour ses structures de donn�es. Windows utilise le mappage de m�moire pour afficher ces zones de m�moire comme si elles faisaient partie du processus de l�application, de fa�on � ce que l�application puisse y acc�der.</span><span class="sxs-lookup"><span data-stu-id="f1818-p122">When an application loads a DLL, the DLL's executable code is loaded into the global heap so that it can be run, and space is allocated on the global heap for its data structures. Windows uses memory mapping to make these areas of memory appear as if they are in the application's process so that the application can access them.</span></span>
  
<span data-ttu-id="f1818-p123">Si une deuxi�me application charge ensuite la DLL, Windows ne r�alise pas une autre copie du code ex�cutable DLL, car cette m�moire est en lecture seule. Windows mappe la m�moire du code ex�cutable DLL aux processus des deux applications. Toutefois, il alloue un deuxi�me espace pour une copie priv�e des structures de donn�es de la DLL, et mappe cette copie au deuxi�me processus uniquement. Cela garantit qu�aucune application ne peut interf�rer avec les donn�es de la DLL de l�autre application.</span><span class="sxs-lookup"><span data-stu-id="f1818-p123">If a second application then loads the DLL, Windows does not make another copy of the DLL executable code, as that memory is read-only. Windows maps the DLL executable code memory to the processes of both applications. It does, however, allocate a second space for a private copy of the DLL's data structures and maps this copy to the second process only. This ensures that neither application can interfere with the DLL data of the other.</span></span>
  
<span data-ttu-id="f1818-p124">Cela signifie que les d�veloppeurs DLL n�ont pas � se pr�occuper des variables statiques et globales, ni des structures de donn�es utilis�es par plusieurs applications, ou plusieurs instances de la m�me application. Chaque instance de chaque application obtient sa propre copie des donn�es de la DLL.</span><span class="sxs-lookup"><span data-stu-id="f1818-p124">This means that DLL developers do not have to be concerned about static and global variables and data structures being accessed by more than one application, or more than one instance of the same application. Every instance of every application gets its own copy of the DLL's data.</span></span>
  
<span data-ttu-id="f1818-p125">Les d�veloppeurs DLL doivent �tre concern�s par la m�me instance d�une application en appelant leur DLL plusieurs fois � partir de diff�rents threads, car cela peut entra�ner un conflit pour les donn�es de cette instance. Pour plus d�informations, voir [Gestion de la m�moire dans Excel](memory-management-in-excel.md).</span><span class="sxs-lookup"><span data-stu-id="f1818-p125">DLL developers do need to be concerned about the same instance of an application calling their DLL many times from different threads, because this can result in contention for that instance's data. For more information, see [Memory Management in Excel](memory-management-in-excel.md).</span></span>
  
## <a name="see-also"></a><span data-ttu-id="f1818-261">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="f1818-261">See also</span></span>

- [<span data-ttu-id="f1818-262">D�veloppement de DLL</span><span class="sxs-lookup"><span data-stu-id="f1818-262">Developing DLLs</span></span>](developing-dlls.md) 
- [<span data-ttu-id="f1818-263">Appel dans Excel � partir du fichier DLL ou XLL</span><span class="sxs-lookup"><span data-stu-id="f1818-263">Calling into Excel from the DLL or XLL</span></span>](calling-into-excel-from-the-dll-or-xll.md)

